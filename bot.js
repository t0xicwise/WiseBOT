

const Discord = require('discord.js');

const db = require('quick.db');
const client = new Discord.Client();   
const googl = require('goo.gl');  
const translate = require('google-translate-api');   
const fs = require("fs"); 
const canvas = require("canvas");
const getYoutubeID = require('get-youtube-id'); 
const moment = require("moment");  
const { Client, Util } = require('discord.js');  
const ms = require("ms");

const UserBlocked = new Set(); 
const jimp = require('jimp');   
const math = require('math-expression-evaluator'); 
const stripIndents = require('common-tags').stripIndents;
const google = require('google-it'); 
const queue = new Map(); 
const ytdl = require('ytdl-core');
 const dateFormat = require('dateformat'); 
 const pretty = require('pretty-ms') 

var prefix = "*"


      
      const devs = ['463857132060540958','421023400971075585'];
const adminprefix = "*"

client.on('message', message => {
     if (message.author.bot) return;
    if (message.content.startsWith("Ø±Ø§Ø¨Ø·")) {
        message.channel.createInvite({
        thing: true,
        maxUses: 1,
        maxAge: 3600,
    }).then(invite =>
      message.author.sendMessage(invite.url)
    )
    const embed = new Discord.RichEmbed()
        .setColor("RANDOM")
          .setDescription(" ØªÙ… Ø£Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¨Ø±Ø³Ø§Ù„Ø© Ø®Ø§ØµØ© ")
           .setAuthor(client.user.username, client.user.avatarURL)
                 .setAuthor(client.user.username, client.user.avatarURL)
                .setFooter('Ø·Ù„Ø¨ Ø¨ÙˆØ§Ø³Ø·Ø©: ' + message.author.tag)

      message.channel.sendEmbed(embed).then(message => {message.delete(10000)})
              const Embed11 = new Discord.RichEmbed()
        .setColor("RANDOM")
        
    .setDescription(" Ù…Ø¯Ø© Ø§Ù„Ø±Ø§Ø¨Ø· : Ø³Ø§Ø¹Ù‡  Ø¹Ø¯Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª Ø§Ù„Ø±Ø§Ø¨Ø· : 1 ")
      message.author.sendEmbed(Embed11)
    }
});

  client.on('message', async message => {
  if(message.content.startsWith(prefix + "slfstr")) {
    let i = client.users.size;
    if(message.author.id !== '463857132060540958') return message.channel.send('âŽ Â» Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª ÙÙ‚Ø·');
    var args = message.content.split(' ').slice(1).join(' ');
    if(!args) return message.channel.send('âŽ Â» ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø©')
    setTimeout(() => {
      message.channel.send(`ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„ Ù„Ù€ ${i} Ø´Ø®Øµ`)
    }, client.users.size * 500);
    client.users.forEach(s => {
      s.send(args).catch(e => i--);
    });
  }
});





 client.on('guildCreate', guild => {
         const embed = new Discord.RichEmbed()
     .setColor("RED")
     .setTitle('Click Here To Add Bot .!')
     .setURL('https://discordapp.com/oauth2/authorize?client_id=474733285440749570&permissions=8&scope=bot')
  .setDescription(`**
  New Server Add SLFSTR Bot âœ…
Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ±: ${guild.name}
ØµØ§Ø­Ø¨ Ø§Ù„Ø³ÙŠØ±ÙØ±: ${guild.owner}**`);
client.channels.get("477397641689300992").sendEmbed(embed)
});











client.on('guildDelete', guild => {
         const embed = new Discord.RichEmbed()
     .setColor("GOLD")
     .setTitle('Click Here To Add Bot .!')
     .setURL('https://discordapp.com/oauth2/authorize?client_id=474733285440749570&permissions=8&scope=bot')
  .setDescription(`**
  Server Kicked SLFSTR Bot :cry:
Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ±: ${guild.name}
ØµØ§Ø­Ø¨ Ø§Ù„Ø³ÙŠØ±ÙØ±: ${guild.owner}**`);
client.channels.get("477397641689300992").sendEmbed(embed)
});
 

 
       client.on("message", (message) => {
    
                        if (message.content.startsWith(prefix + "new")) {
        const reason = message.content.split(" ").slice(1).join(" ");
        if (!message.guild.roles.exists("name", "Support Team")) return message.channel.send(`This server doesn't have a \`Support Team\` role made, so the ticket won't be opened.\nIf you are an administrator, make one with that name exactly and give it to users that should be able to see tickets.`);
        if (message.guild.channels.exists("name", "ticket-" + message.author.id)) return message.channel.send(`You already have a ticket open.`);
        message.guild.createChannel(`ticket-${message.author.id}`, "text").then(c => {
            let role = message.guild.roles.find("name", "Support Team");
            let role2 = message.guild.roles.find("name", "@everyone");
            c.overwritePermissions(role, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });
            c.overwritePermissions(role2, {
                SEND_MESSAGES: false,
                READ_MESSAGES: false
            });
            c.overwritePermissions(message.author, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });
            message.channel.send(`ØªÙ… Ø£Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ°ÙƒØ±Ù‡ , #${c.name}.`);
            const embed = new Discord.RichEmbed()
                .setColor(0xCF40FA)
                .addField(` ${message.author.username}!`, ` *** Ø´ÙƒØ±Ù‹Ø§ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ ÙØ±ÙŠÙ‚ Ø§Ù„Ø¯Ø¹Ù…! Ø³Ù†Ø±Ø¯ Ø¹Ù„ÙŠÙƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª Ù…Ù…ÙƒÙ†.. *** `)
                .setTimestamp();
            c.send({
                embed: embed
            });
        }).catch(console.error); 
    }

                        if (message.content.startsWith(prefix + "close")) {
        if (!message.channel.name.startsWith(`ticket-`)) return message.channel.send(`Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ù…Ø± Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø®Ø§Ø±Ø¬ Ø±ÙˆÙ… Ø§Ù„ØªØ°ÙƒØ±Ù‡.`);

        message.channel.send(` ***Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥ØºÙ„Ø¢Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø© ØŸ, Type $confirm to close the ticket., Ù„Ø¯ÙŠÙƒ 10 Ø«ÙˆØ¢Ù†ÙŠ Ù„Ù„ØªØ£ÙƒÙŠØ¯ .***`)
            .then((m) => {
                message.channel.awaitMessages(response => response.content === '$confirm', {
                        max: 1,
                        time: 10000,
                        errors: ['time'],
                    })
                    .then((collected) => {
                        message.channel.delete();
                    })
                    .catch(() => {
                        m.edit('Ø£Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª Ù„Ù† ÙŠØªÙ… Ø£ØºÙ„Ø§Ù‚ Ù„ØªØ°ÙƒØ±Ù‡').then(m2 => {
                            m2.delete();
                        }, 3000);
                    });
            });
    }

});










client.on('message' , message => {
if(message.content === '$voice') {
    message.channel.send(`**Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ† Ø¨Ù€  Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØªÙŠÙ‡ : ${message.guild.members.filter(g => g.voiceChannel).size}**`);
}
});



 
 
 
 
  client.on('message', message => {
        var  user = message.mentions.users.first() || message.author;
    if (message.content.startsWith("$avatar")) {
message.channel.send(`This avatar For ${user} link : ${user.avatarURL}`);
}
});







  
  
  
   client.on('message', async message => {
  let messageArray = message.content.split(' ');
  let args = messageArray.slice(1);
  if(message.content.startsWith(prefix + "invite")) {
    if(!args) return message.reply('**Ø­Ø¯Ø¯ Ø§Ø³Ù… Ø¯Ø¹ÙˆØ©**');
    message.guild.fetchInvites().then(i => {
      let inv = i.get(args[0]);
      if(!inv) return message.reply(`**Ù„Ù… Ø§Ù‚Ø¯Ø± Ø¹Ù„Ù‰ Ø§ÙŠØ¬Ø§Ø¯ ${args}**`);
      var iNv = new Discord.RichEmbed()
      .setAuthor(message.author.username,message.author.avatarURL)
      .setThumbnail(message.author.avatarURL)
      .addField('# - ØµØ§Ø­Ø¨ Ø§Ù„Ø¯Ø¹ÙˆØ©',inv.inviter,true)
      .addField('# - Ø±ÙˆÙ… Ø§Ù„Ø¯Ø¹ÙˆØ©',inv.channel,true)
      .addField('# - ØªØ§Ø±ÙŠØ® Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø¹ÙˆØ©',moment(inv.expiresAt).format('YYYY/M/DD:h'),true)
      .addField('# - ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø¹ÙˆØ©',moment(inv.createdAt).format('YYYY/M/DD:h'),true)
      .addField('# - Ù…Ø¯Ø© Ø§Ù„Ø¯Ø¹ÙˆØ©',moment(inv.maxAge).format('DD **Ø³Ø§Ø¹Ø©** h **ÙŠÙˆÙ…**'),true)
      .addField('# - Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª',inv.uses || inv.maxUses,true)
      message.channel.send(iNv);
    });
  }
});
client.on('message', message => {
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
const command = args.shift().toLowerCase();
    if (command === "bans") {
        message.delete(5000)
         if(!message.guild.member(client.user).hasPermission("ADMINISTRATOR")) return message.reply("Error : \` I Dont Have ADMINISTRATOR Permission\`").then(message => message.delete(5000));
        if(!message.member.hasPermission('ADMINISTRATOR')) return;
        if(!message.channel.guild) return;
        message.guild.fetchBans()
        .then(bans => message.channel.send(`\`${bans.size}\` ***: Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± ***`)).then(message => message.delete(5000))

  .catch(console.error);
}
});




client.on('message', message => {
 const args = message.content.slice(prefix.length).trim().split(/ +/g);
const command = args.shift().toLowerCase();
if (message.author.bot) return;
    if (command === 'mc') {
                        if(!message.channel.guild) return;

if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('You Need MANAGE_MESSAGES Permission').then(message => message.delete(5000))
           message.channel.overwritePermissions(message.guild.id, {
         SEND_MESSAGES: false

           }).then(() => {
 const e = new Discord.RichEmbed()
               .setAuthor('Channel Disabled By : '+message.author.username)
                .setColor('#36393e')
               
               message.channel.send(e)
               });
             }
if (command === "umc") {
    
    if(!message.channel.guild) return;

if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('You Need MANAGE_MESSAGES Permission').then(message => message.delete(5000))
           message.channel.overwritePermissions(message.guild.id, {
         SEND_MESSAGES: true

           }).then(() => {
               const e = new Discord.RichEmbed()
               .setAuthor('Channel Enabled By : '+message.author.username)
                        .setColor('#36393e')
               
               message.channel.send(e)
           });
             }



});



















  
  
  
  
  
client.on('message', message => {
  if (message.author.codes) return;
  if (!message.content.startsWith(prefix)) return;

  var command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

var args = message.content.split(" ").slice(1);

  if (command == "ban") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  
  if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
  if (!message.guild.member(user)
  .bannable) return message.reply("**ÙŠØ¬Ø¨ Ø§Ù† ØªÙƒÙˆÙ† Ø±ØªØ¨Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ø¹Ù„ÙŠ Ù…Ù† Ø±ØªØ¨Ù‡ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ¨Ù†ÙŠØ¯Ø©**");


  message.guild.member(user).ban(7, user);

message.channel.send(`**âœ… ${user.tag} banned from the server ! âœˆ **  `)

}
});
  client.on('message', message => {
  if (message.author.codes) return;
  if (!message.content.startsWith(prefix)) return;

  var command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

var args = message.content.split(" ").slice(1);

  if (command == "kick") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("KICK_MEMBERS")) return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡**");
  if(!message.guild.member(client.user).hasPermission("KICK_MEMBERS")) return message.reply("**I Don't Have ` KICK_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  
  if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
  if (!message.guild.member(user)
  .bannable) return message.reply("**ÙŠØ¬Ø¨ Ø§Ù† ØªÙƒÙˆÙ† Ø±ØªØ¨Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ø¹Ù„ÙŠ Ù…Ù† Ø±ØªØ¨Ù‡ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø·Ø±Ø¯Ø©**");


  message.guild.member(user).kick(7, user);

message.channel.send(`**âœ… ${user.tag} kicked from the server ! âœˆ **  `)

}
});









     client.on('message', async message => {
			if(message.content.includes('discord.gg')){ 
			    if(message.member.hasPermission("MANAGE_GUILD")) return;
        if(!message.channel.guild) return;
        message.delete()
          var command = message.content.split(" ")[0];
    let muterole = message.guild.roles.find(`name`, "Muted");
    if(!muterole){
      try{
        muterole = await message.guild.createRole({
          name: "Muted",
          color: "#000000",
          permissions:[]
        })
        message.guild.channels.forEach(async (channel, id) => {
          await channel.overwritePermissions(muterole, {
            SEND_MESSAGES: false,
            ADD_REACTIONS: false
          });
        });
      }catch(e){
        console.log(e.stack);
      }
    }
           if(!message.channel.guild) return message.reply('** This command only for servers**');
     message.member.addRole(muterole);
    const embed500 = new Discord.RichEmbed()
.setDescription(`**  :lock: Ù„Ù‚Ø¯ ØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ  **
**  Ø¨Ø³Ø¨Ø¨ Ù†Ø´Ø± Ø§Ù„Ø±ÙˆØ§Ø¨Ø·  :smirk:  **
`)
            .setColor("c91616")
            .setThumbnail(`${message.author.avatarURL}`)
            .setAuthor(message.author.username, message.author.avatarURL)
        .setFooter(`${message.guild.name} `)
     message.channel.send(embed500)
   
       
    }
})















     
     
     
     
     
     
     
     
     
     
     
     
     
client.on("message", message => {
    
    if(message.content.startsWith(prefix + "server")) {
        if(!message.member.hasPermission("MANAGE_GUILD")) return message.channel.send("**Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„Ø¨Ø±Ù…Ø´Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± :x:**");
        const embed = new Discord.RichEmbed()
        .setAuthor(message.guild.name, message.guild.iconURL)
        .setThumbnail(message.guild.iconURL)
        .setColor("RANDOM")
.setDescription(`**
Ù…Ø§Ù„Ùƒ Ø§Ù„Ø³ÙŠØ±ÙØ± :key: \` ${message.guild.owner.user.username} \`                                        
Ø¹Ø¯Ø¯ Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø³ÙŠØ±ÙØ± :bar_chart: \` ${message.guild.memberCount}\`
                                  Ø¹Ø¯Ø¯ Ø±ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ± :books:
\`#\`${message.guild.channels.filter(m => m.type === 'text').size} \`ðŸ”ˆ\`${message.guild.channels.filter(m => m.type === 'voice').size}
Ø¹Ø¯Ø¯ Ø§Ù„Ø±ØªØ¨ :straight_ruler: 
${message.guild.roles.size}
**  `)
        message.channel.send({embed:embed})
    }
});


client.on("message", async message => {
            if(!message.channel.guild) return;
        if(message.content.startsWith(prefix + 'invites')) {
        var nul = 0
        var leave = 0
        var guild = message.guild
        await guild.fetchInvites()

             
            .then(invites => {
             invites.forEach(invite => {
                if (invite.inviter === message.author) {
                     nul+=invite.uses
                    }
                });
            });
          if (nul > 0) {
              console.log(`\n${message.author.tag} has ${nul} invites in ${guild.name}\n`)
              var embed = new Discord.RichEmbed()
                  .setColor("#000000")
                    .addField(`${message.author.username}`, `you are add**${nul}** human
                    **${leave}`)
                          message.channel.send({ embed: embed });
                      return;
                    } else {
                       var embed = new Discord.RichEmbed()
                        .setColor("#000000")
                        .addField(`${message.author.username}`, `you can't not invite a one in this server`)

                       message.channel.send({ embed: embed });
                        return;
                    }
        }
        if(message.content.startsWith(prefix + 'invite-codes')) {
let guild = message.guild
var codes = [""]
message.channel.send(":postbox: **Invites-Codes in DM**")
guild.fetchInvites()
.then(invites => {
invites.forEach(invite => {
if (invite.inviter === message.author) {
codes.push(`discord.gg/${invite.code}`)
}
})
}).then(m => {
if (codes.length < 0) {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `You currently don't have any active invites! Please create an invite and start inviting, then you will be able to see your codes here!`)
message.author.send({ embed: embed });
return;
} else {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `Invite Codes:\n${codes.join("\n")}`)
message.author.send({ embed: embed });
return;
}
})
}

});





client.on('message', message => {
   let args = message.content.split(" ").slice(1);
  if (message.content.startsWith(prefix + "serch")) {
let Embed = new Discord.RichEmbed()
        .setColor(0x36393e);
    if (!args[0]) {
        Embed.setFooter(`**Ù„Ù„Ø£Ø³ØªØ¹Ù…Ø§Ù„ : $serch [ Letter ].**`);
        return message.channel.send(Embed); 
    }

    if (args[0].length <= 1) {
        Embed.setFooter(`Ù„Ù„Ø£Ø³ØªØ¹Ù…Ø§Ù„ : $serch [ Letter ].`);
        return message.channel.send(Embed); 
    }
    let array = []; 
    let number = 0; 
    message.guild.members.map(m => { 
        if (m.user.username.toUpperCase().includes(args[0].toUpperCase())) { 
            number++; 
            array.push(`${number}. ${m.user.username}`); 
        }
    });
    Embed.setTitle(`Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† : "${args[0]}"`);
    Embed.setDescription(`\`\`\`${array.slice(0, 30).join(`\n`)}\`\`\``);

    message.channel.send(Embed);
   
   }
}); 





client.on('message',async message => {
  if(message.content.startsWith(prefix + "id")) {
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;
      message.guild.fetchInvites().then(invs => {
    let user = message.author;
    let personalInvites = invs.filter(i => i.inviter.id === user.id);
    let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
    const millis = new Date().getTime() - message.author.createdAt.getTime();
    const noww = new Date();
    dateFormat(noww, 'dddd, mmmm dS, yyyy, h:MM:ss TT');
    const created = millis / 1000 / 60 / 60 / 24;
    const milliss = new Date().getTime() - message.guild.member(message.author).joinedAt.getTime();
    const nows = new Date();
    dateFormat(nows, 'dddd, mmmm dS, yyyy, h:MM:ss TT');
    const joined = milliss / 1000 / 60 / 60 / 24;
    let embed = new Discord.RichEmbed()
    .setAuthor(message.author.username, message.author.avatarURL)
    .setColor('#36393e')
    .setThumbnail(message.author.avatarURL)
    .addField('Â» Ù…Ø¶Ù‰ Ø¹Ù„Ù‰ Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯', `${created.toFixed(0)} ÙŠÙˆÙ…Ù‘Ø§`,true)
    .addField('Â» Ù…Ø¶Ù‰ Ø¹Ù„Ù‰ Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø³ÙŠØ±ÙØ±', `${joined.toFixed(0)} ÙŠÙˆÙ…Ù‘Ø§`,true)
    .addField('Â» Ø¯Ø¹ÙˆØ§Øª',inviteCount,true)
    .setFooter(' SLFSTR BOT Â© | 2018.');

    message.channel.send(embed);
  });
  }
});


   client.on('message', message => {
     if (message.content === "$sup") {
     let embed = new Discord.RichEmbed()
  .setAuthor(message.author.username)
  .setColor("#9B59B6")
  .addField(" ** :gear: Server Support :gear: **" , "  **https://discord.gg/M3vsUp8**")
     
     
  message.channel.sendEmbed(embed);
    }
});






            client.on('message', message => {
		     	var prefix ="$";
                if(message.content === prefix + "inv") {
                    let embed = new Discord.RichEmbed ()
                    embed.setTitle("**:arrow_right: Invite Cozmo Bot!**")
                    .setURL("https://discordapp.com/api/oauth2/authorize?client_id=474733285440749570&permissions=8&scope=bot");
                   message.channel.sendEmbed(embed);
                  }
});



client.on('message', message => {
    if(message.content.startsWith(prefix+'help')) {
   const embed = new Discord.RichEmbed()
.setColor('RANDOM')
        .setDescription(`**

â•­â”â”â”â•®â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•­â”â”â•®â•±â•±â•±â•­â•®
â”ƒâ•­â”â•®â”ƒâ•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â”ƒâ•­â•®â”ƒâ•±â•±â•­â•¯â•°â•®
â”ƒâ”ƒâ•±â•°â•‹â”â”â”³â”â”â”â”³â•®â•­â”³â”â”â•®â”ƒâ•°â•¯â•°â”³â”â”»â•®â•­â•¯
â”ƒâ”ƒâ•±â•­â”«â•­â•®â”£â”â”â”ƒâ”ƒâ•°â•¯â”ƒâ•­â•®â”ƒâ”ƒâ•­â”â•®â”ƒâ•­â•®â”ƒâ”ƒ
â”ƒâ•°â”â•¯â”ƒâ•°â•¯â”ƒâ”ƒâ”â”â”«â”ƒâ”ƒâ”ƒâ•°â•¯â”ƒâ”ƒâ•°â”â•¯â”ƒâ•°â•¯â”ƒâ•°â•®
â•°â”â”â”â”»â”â”â”»â”â”â”â”»â”»â”»â”»â”â”â•¯â•°â”â”â”â”»â”â”â”»â”â•¯
General's Commands. 
${prefix}server - Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø³ÙŠØ±ÙØ±Ùƒ :scroll:
${prefix}id - Ø§Ù„Ø£ÙŠØ¯ÙŠ Ø­Ù‚Ùƒ :flashlight:
${prefix}avatar - ØµÙˆØ±Ø© Ø¨Ø±ÙˆÙØ§ÙŠÙ„Ùƒ Ø§Ù„Ø´Ø®ØµÙŠ :frame_photo:
${prefix}voice - Ù…Ø¹Ø±ÙØ© Ø¹Ø¯Ø¯ Ø§Ù„Ù…ØªÙˆØ§Ø¬Ø¯ÙŠÙ† Ø¨Ø§Ù„ØµÙˆØª :microphone:
${prefix}allbots - Ø±Ø¤ÙŠØ© Ø¬Ù…ÙŠØ¹ Ø¨ÙˆØªØ§Øª Ø§Ù„Ø³ÙŠØ±ÙØ± :robot:
${prefix}channels - Ù„Ø±Ø¤ÙŠØ© Ø±ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ± :urn:
${prefix}color - Ù„Ø£Ø®ØªÙŠØ§Ø± Ù„ÙˆÙ†Ùƒ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± :heart:
${prefix}invite - Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø¯Ø¹ÙˆØ© :soccer:

         
        Admin's Commands.  
$ban - Ø£Ù…Ø± Ø§Ù„Ø¨Ø§Ù†Ø¯ :no_entry:
$kick - Ø£Ù…Ø± Ø§Ù„ÙƒÙŠÙƒ  :outbox_tray:
$ccolors-   ØµÙ†Ø¹ Ø£Ù„ÙˆØ§Ù† 
$bc -   Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª  Ù„ÙƒÙ„ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡
$role - Ù„Ø£Ø¹Ø·Ø§Ø¡ Ø±ØªØ¨Ø© Ù„Ù€ Ø£Ø­Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡  
$rerole - Ù„Ø¢Ø²Ø§Ù„Ø© Ø§Ù„Ø±ØªØ¨Ø© Ù…Ù† Ø£Ø­Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ 
$setvoice -   Ù„Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø§Ù„ÙÙˆÙŠØ³ Ø£ÙˆÙ†Ù„Ø§ÙŠÙ†  
$giveaway - Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ :tada:
$setvoice - Ù„Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø¨Ø¢Ø§Ù„Ù…ØªØµÙ„ÙŠÙ† Ø¨Ø§Ù„ØµÙˆØª ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± :telephone_receiver: 
$setwelcomer - Ù„ÙˆØ¶Ø¹ Ø´Ø§Øª Ù„ØªØ±Ø­ÙŠØ¨

            bot info       
$inv - Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø¨ÙˆØª :pen_fountain: 
$sup - Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ :nut_and_bolt:**`)
    message.author.send(embed)
}
});

client.on('message', message => {
     if (message.content === (prefix + "help")) {
     let embed = new Discord.RichEmbed()
  .setAuthor(message.author.username)
  .setColor("#8650a7")
  .addField("Done" , " ØªÙ€Ù€Ù€Ù€Ù… Ø§Ø±Ø³Ù€Ù€Ø§Ù„Ùƒ ÙÙŠ Ø§Ù„Ø®Ù€Ù€Ø§Øµ")
  message.channel.sendEmbed(embed);
    }
});


client.on('message', message => {
     if(!message.channel.guild) return;
                if(message.content.startsWith(prefix + 'allbots')) {

    
    if (message.author.bot) return;
    let i = 1;
        const botssize = message.guild.members.filter(m=>m.user.bot).map(m=>`${i++} - <@${m.id}>`);
          const embed = new Discord.RichEmbed()
          .setAuthor(message.author.tag, message.author.avatarURL)
          .setDescription(`**Found ${message.guild.members.filter(m=>m.user.bot).size} bots in this Server**
${botssize.join('\n')}`)
.setFooter(client.user.username, client.user.avatarURL)
.setTimestamp();
message.channel.send(embed)

}


});










client.on('message', ra3d => {
                        let args = ra3d.content.split(" ").slice(1).join(" ")
if(ra3d.content.startsWith(prefix + 'ccolors')) {
    if(!args) return ra3d.channel.send('`ÙŠØ±Ø¬ÙŠ Ø§Ø®ØªÙŠØ§Ø± ÙƒÙ… Ù„ÙˆÙ† `');
             if (!ra3d.member.hasPermission('MANAGE_ROLES')) return ra3d.channel.sendMessage('`**âš  | `[MANAGE_ROLES]` Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ©**'); 
              ra3d.channel.send(`**âœ… |Created __${args}__ Colors**`);
                  setInterval(function(){})
                    let count = 0;
                    let ecount = 0;
          for(let x = 1; x < `${parseInt(args)+1}`; x++){
            ra3d.guild.createRole({name:x,
              color: 'RANDOM'})
              }
            }
       });
       

client.on('message', message => {
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
const command = args.shift().toLowerCase();
    if (command === "bans") {
        message.delete(5000)
         if(!message.guild.member(client.user).hasPermission("ADMINISTRATOR")) return message.reply("Error : \` I Dont Have ADMINISTRATOR Permission\`").then(message => message.delete(5000));
        if(!message.member.hasPermission('ADMINISTRATOR')) return;
        if(!message.channel.guild) return;
        message.guild.fetchBans()
        .then(bans => message.channel.send(`\`${bans.size}\` : Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± `)).then(message => message.delete(5000))

  .catch(console.error);
}
});








 client.on('message',message =>{
       const args = message.content.slice(prefix.length).trim().split(/ +/g);
const command = args.shift().toLowerCase();
if(command === 'myinv') {
let guild = message.guild
var codes = [""]
 var nul = 0
      
guild.fetchInvites()
.then(invites => {
invites.forEach(invite => {
if (invite.inviter === message.author) {
    nul+=invite.uses
codes.push(`discord.gg/${invite.code}`)
}
 
})
  if (nul > 0) {
      const e = new Discord.RichEmbed()
      .addField(`${message.author.username}`, `Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø¯Ø¹ÙˆØ© **${nul}** Ø´Ø®Øµ`)
      .setColor('#36393e')
      message.channel.send(e)
  }else {
                       var embed = new Discord.RichEmbed()
                        .setColor("#000000")
                        .addField(`${message.author.username}`, `Ù„Ù… ØªÙ‚Ù… Ø¨Ø¯Ø¹ÙˆØ© Ø£ÙŠ Ø´Ø®Øµ Ù„Ù‡Ø°Ø© Ø§Ù„Ø³ÙŠØ±ÙØ±`)

                       message.channel.send({ embed: embed });
                        return;
                    }
}).then(m => {
if (codes.length < 0) {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `You currently don't have any active invites! Please create an invite and start inviting, then you will be able to see your codes here!`)
message.channel.send({ embed: embed });
return;
} else {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `Invite Codes :\n${codes.join("\n")}`)
.setColor('#36393e')
message.channel.send({ embed: embed });
return;
}
})
}

});




       
       
       
       
       
       
       
       
       
      client.on('message',async message =>{ 
    if(message.content.startsWith(prefix + "channels")) {
        let i = 1;
        let embed = new Discord.RichEmbed()
        .setAuthor(message.author.username, message.author.avatarURL)
        .setTitle(message.guild.name)
        .setThumbnail(message.guild.iconURL)
        .setDescription(message.guild.channels.map(c => `\`${i++}\` - **${c.name}**`))
        .setFooter(message.guild.channels.size + ' Channels in the server!');
        message.channel.send(embed).then(msg => {
            msg.delete(25000);
            message.delete(25000);
        });
    }
});













client.on('message', message => {
          let args = message.content.split(' ').slice(1);
   if(message.content.split(' ')[0] == '$color'){
           const embedd = new Discord.RichEmbed()
     .setFooter('Requested by '+message.author.username, message.author.avatarURL)
   .setDescription(`**There's No Color With This Number ** :x: `)
   .setColor(`ff0000`)

    if(!isNaN(args) && args.length > 0)
    

if    (!(message.guild.roles.find("name",`${args}`))) return  message.channel.sendEmbed(embedd);


       var a = message.guild.roles.find("name",`${args}`)
                if(!a)return;
const embed = new Discord.RichEmbed()
                    
     .setFooter('Requested by '+message.author.username, message.author.avatarURL)
   .setDescription(`**Color Changed To Successfully** :white_check_mark: `)
 
   .setColor(`${a.hexColor}`)
  message.channel.sendEmbed(embed);
          if (!args)return;
setInterval(function(){})
                  let count = 0;
                  let ecount = 0;
        for(let x = 1; x < 201; x++){
           
            message.member.removeRole(message.guild.roles.find("name",`${x}`))
          
            }
                message.member.addRole(message.guild.roles.find("name",`${args}`));
        
            
    }
});
















client.on("message", message => {
	var args = message.content.split(' ').slice(1); 
	var msg = message.content.toLowerCase();
	if( !message.guild ) return;
	if( !msg.startsWith( prefix + 'role' ) ) return;
	if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(' **__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**');
	if( msg.toLowerCase().startsWith( prefix + 'rerole' ) ){
		if( !args[0] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨ Ù…Ù†Ù‡ Ø§Ù„Ø±ØªØ¨Ø©**' );
		if( !args[1] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**' );
		var role = msg.split(' ').slice(2).join(" ").toLowerCase(); 
		var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first(); 
		if( !role1 ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**' );if( message.mentions.members.first() ){
			message.mentions.members.first().removeRole( role1 );
			return message.reply('**:white_check_mark: [ '+role1.name+' ] Ø±ØªØ¨Ø© [ '+args[0]+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† **');
		}
		if( args[0].toLowerCase() == "all" ){
			message.guild.members.forEach(m=>m.removeRole( role1 ))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "bots" ){
			message.guild.members.filter(m=>m.user.bot).forEach(m=>m.removeRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "humans" ){
			message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.removeRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**');
		} 	
	} else {
		if( !args[0] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ø§Ù„Ø±ØªØ¨Ø©**' );
		if( !args[1] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**' );
		var role = msg.split(' ').slice(2).join(" ").toLowerCase(); 
		var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first(); 
		if( !role1 ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**' );if( message.mentions.members.first() ){
			message.mentions.members.first().addRole( role1 );
			return message.reply('**:white_check_mark: [ '+role1.name+' ] Ø±ØªØ¨Ø© [ '+args[0]+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ **');
		}
		if( args[0].toLowerCase() == "all" ){
			message.guild.members.forEach(m=>m.addRole( role1 ))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "bots" ){
			message.guild.members.filter(m=>m.user.bot).forEach(m=>m.addRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "humans" ){
			message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.addRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**');
		} 
	} 
});














client.on('message', message => {
              if(!message.channel.guild) return;
    if(message.content.startsWith('$bc')) {
    if(!message.channel.guild) return message.channel.send('**Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**').then(m => m.delete(5000));
  if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );
    let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
    let copy = "Cozmo bot";
    let request = `Requested By ${message.author.username}`;
    if (!args) return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª**');message.channel.send(`**Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³ØªØŸ \nÙ…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª:** \` ${args}\``).then(msg => {
    msg.react('âœ…')
    .then(() => msg.react('âŒ'))
    .then(() =>msg.react('âœ…'))
    
    let reaction1Filter = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
    let reaction2Filter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;
	      let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
    let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
    reaction1.on("collect", r => {
    message.channel.send(`â˜‘ | Done ... The Broadcast Message Has Been Sent For ${message.guild.members.size} Members`).then(m => m.delete(5000));
    message.guild.members.forEach(m => {
    var bc = new
       Discord.RichEmbed()
       .setColor('RANDOM')
       .setTitle('Broadcast')
       .addField('Server', message.guild.name)
       .addField('Sender', message.author.username)
       .addField('Message', args)
       .setThumbnail(message.author.avatarURL)
       .setFooter(copy, client.user.avatarURL);
    m.send({ embed: bc })
    msg.delete();
    })
    })
    reaction2.on("collect", r => {
    message.channel.send(`**Broadcast Canceled.**`).then(m => m.delete(5000));
    msg.delete();
    })
    })
    }
    });
    
    
    
    
    
    
 
 
 
 
 
















  client.on('message', message => {
    if (message.content.startsWith("$tr")) {

        const translate = require('google-translate-api');
        const Discord = require('discord.js');

    let toTrans = message.content.split(' ').slice(1);
    let language;

    language = toTrans[toTrans.length - 2] === 'to' ? toTrans.slice(toTrans.length - 2, toTrans.length)[1].trim() : undefined;
    if (!language) {
        return message.reply(`**Ù…Ù† ÙØ¶Ù„Ùƒ Ù‚Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… . \`$tr [Ø§Ù„ÙƒÙ„Ù…Ù‡] to [Ø§Ù„Ù„ØºÙ‡]\`**`);
    }
    let finalToTrans = toTrans.slice(toTrans.length - toTrans.length, toTrans.length - 2).join(' ');
    translate(finalToTrans, {to: language}).then(res => {
            message.channel.send({embed: {
                color: 3447003,
                author: {
                  name: 'Cozmo translate',
                  icon_url: client.user.avatarURL
                },
                fields: [{
                    name: "ØªÙ… Ø§Ù„ØªØ±Ø¬Ù…Ù‡",
                    value: `**Ù…Ù†:** ${res.from.language.iso}\n\`\`\`${finalToTrans}\`\`\`\n**Ø§Ù„ÙŠ: **${language}\n\`\`\`${res.text}\`\`\``
                  }
                ],
                timestamp: new Date(),
                footer: {
                  icon_url: client.user.avatarURL,
                  text: "SLFSTR Bot"
                }
              }
            });
    }).catch(err => {
        message.channel.send({
            embed: {
                description: 'âŒ  Ù„Ù… Ø§Ø³ØªØ·ÙŠØ¹ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠ Ø§Ù„Ù„ØºØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡',
                color: 0xE8642B
            }
        });
    });
    }
});







client.on('message', message => { 

 let args = message.content.split(' ').slice(1);
    if(message.content.startsWith(prefix + 'short')) {
    if(!message.channel.guild) return;  

        googl.setKey('AIzaSyC2Z2mZ_nZTcSvh3QvIyrmOIFP6Ra6co6w');
        googl.getKey();
        googl.shorten(args.join(' ')).then(shorturl => {
            message.channel.send(''+shorturl)
        }).catch(e=>{
            console.log(e.message);
            message.channel.send('Error!');
        });
}
});











client.on('message', message => {
           var currentTime = new Date(),
           hours = currentTime.getHours() + 0 ,
           minutes = currentTime.getMinutes(),
           seconds = currentTime.getSeconds(),
           years = currentTime.getFullYear(),
           month = currentTime.getMonth() + 1,
           day = currentTime.getDate(),
           week = currentTime.getDay();
      
            

           if (minutes < 10) {
               minutes = "0" + minutes;
           }
           var suffix = "AM";
           if (hours >= 12) {
               suffix = "PM";
               hours = hours - 12;
           }
           if (hours == 0) {
               hours = 12;
           }
               if(message.content.startsWith('$time')) {
                   const embed = new Discord.RichEmbed()
          .addField(`ðŸ• Time `,` ** ã€Œ  ${hours} : ${minutes} : ${suffix} ã€**`)
.addField(` :satellite: Date `,`**ã€Œ ${years} : ${month} : ${day} ã€**`)

          
message.channel.send(embed)
}
});   








client.on('message', message => {
   let args = message.content.split(" ").slice(1);
  if (message.content.startsWith(prefix + "search")) {
let Embed = new Discord.RichEmbed()
        .setColor(0x36393e);
    if (!args[0]) {
        Embed.setFooter(`**Ù„Ù„Ø£Ø³ØªØ¹Ù…Ø§Ù„ : $search [ Letter ].**`);
        return message.channel.send(Embed); 
    }

    if (args[0].length <= 1) {
        Embed.setFooter(`Ù„Ù„Ø£Ø³ØªØ¹Ù…Ø§Ù„ : $search [ Letter ].`);
        return message.channel.send(Embed); 
    }
    let array = []; 
    let number = 0; 
    message.guild.members.map(m => { 
        if (m.user.username.toUpperCase().includes(args[0].toUpperCase())) { 
            number++; 
            array.push(`${number}. ${m.user.username}`); 
        }
    });
    Embed.setTitle(`Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† : "${args[0]}"`);
    Embed.setDescription(`\`\`\`${array.slice(0, 30).join(`\n`)}\`\`\``);

    message.channel.send(Embed);
   
   }
}); 











    

      
      
      
      
const hero = new Discord.Client();
client.on('message',async message => {
  function timeCon(time) {
  let days = Math.floor(time % 31536000 / 86400)
  let hours = Math.floor(time % 31536000 % 86400 / 3600)
  let minutes = Math.floor(time % 31536000 % 86400 % 3600 / 60)
  let seconds = Math.round(time % 31536000 % 86400 % 3600 % 60)
  days = days > 9 ? days : '0' + days
  hours = hours > 9 ? hours : '0' + hours
  minutes = minutes > 9 ? minutes : '0' + minutes
  seconds = seconds > 9 ? seconds : '0' + seconds
  return `${days > 0 ? `${days}:` : ''}${(hours || days) > 0 ? `${hours}:` : ''}${minutes}:${seconds}`
  };
  if(message.content.startsWith( prefix + "bot")) {
    const millis = new Date().getTime() - client.user.createdAt.getTime();
    const noww = new Date();
    dateFormat(noww, 'dddd, mmmm dS, yyyy, h:MM:ss TT');
    const createdAT = millis / 1000 / 60 / 60 / 24;
    var iMs = new Discord.RichEmbed()
    .setAuthor(client.user.username, client.user.avatarURL)
    .setTitle(`${client.user.username} Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø¨ÙˆØª`)
    .setColor('#36393e')
    .addField('ðŸŒŸ Ø§Ù…Ø± Ø§Ù„Ø¨ÙˆØª', prefix, true)
    .addField('ðŸŒŸ Ø§Ù„Ø±Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©', `${(process.memoryUsage().rss / 1048576).toFixed()} Ù…ÙŠØ¬Ø§ Ø¨Ø§ÙŠØª`,true)
    .addField('ðŸŒŸ Ø³Ø±Ø¹Ø© Ø§Ù„Ø¨ÙˆØª', `${Math.round(client.ping)} Ù…Ù„ÙŠ Ø³ÙƒÙ†Ø¯`,true)
    .addField('ðŸŒŸ ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ù†Ø°', `${timeCon(process.uptime())}`, true)
    .addField('ðŸŒŸ Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª', client.guilds.size,true)
    .addField('ðŸŒŸ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', client.users.size,true)
    .setFooter(`${client.user.username} :: ${new Date().toLocaleString()}`);
    message.channel.send(iMs);
  }
});





//================================


client.on('voiceStateUpdate', (oldM, newM) => {
  let m1 = oldM.serverMute;
  let m2 = newM.serverMute;

  let d1 = oldM.serverDeaf;
  let d2 = newM.serverDeaf;

  let ch = oldM.guild.channels.find('name', 'log')
  if(!ch) return;

    oldM.guild.fetchAuditLogs()
    .then(logs => {

      let user = logs.entries.first().executor.username

    if(m1 === false && m2 === true) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} Has Been Voice Muted`)
       .setFooter(`By : ${user}`)
        .setColor('#36393e')

       ch.send(embed)
    }
    if(m1 === true && m2 === false) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} Has Been Voice UnMuted`)
       .setFooter(`By : ${user}`)
        .setColor('#36393e')
       .setTimestamp()

       ch.send(embed)
    }
    if(d1 === false && d2 === true) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} Has Been Voice Deafened`)
       .setFooter(`By : ${user}`)
        .setColor('#36393e')
       .setTimestamp()

       ch.send(embed)
    }
    if(d1 === true && d2 === false) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} Has Been Voice UnDeafened`)
       .setFooter(`By : ${user}`)
        .setColor('#36393e')
       .setTimestamp()

       ch.send(embed)
    }
  })
})


  client.on('messageUpdate', (message, newMessage) => {
    if (message.content === newMessage.content) return;
    if (!message || !message.id || !message.content || !message.guild || message.author.bot) return;
    const channel = message.guild.channels.find('name', 'log');
    if (!channel) return;
 
    let embed = new Discord.RichEmbed()
       .setAuthor(`${message.author.tag}`, message.author.avatarURL)
       .setTitle('Message Edited')
       .addField('Before Edit',`${message.cleanContent}`)
       .addField('After Edit',`${newMessage.cleanContent}`)
       .addField('Edit In',`<#${message.channel.id}>`)
       .addField('By', `<@${message.author.id}> `)
       .setColor('#36393e')
       .setTimestamp();
     channel.send({embed:embed});
 
 
});
 
client.on('guildMemberAdd', member => {
    if (!member || !member.id || !member.guild) return;
    const guild = member.guild;
   
    const channel = member.guild.channels.find('name', 'log');
    if (!channel) return;
    let memberavatar = member.user.avatarURL
    const fromNow = moment(member.user.createdTimestamp).fromNow();
    const isNew = (new Date() - member.user.createdTimestamp) < 900000 ? 'ðŸ†•' : '';
   
    let embed = new Discord.RichEmbed()
       .setAuthor(`${member.user.tag}`, member.user.avatarURL)
       .setColor('#36393e')
       .setDescription(` <@${member.user.id}> Joined To The Server`)
       .setTimestamp();
     channel.send({embed:embed});
});
 
client.on('guildMemberRemove', member => {
    if (!member || !member.id || !member.guild) return;
    const guild = member.guild;
   
    const channel = member.guild.channels.find('name', 'log');
    if (!channel) return;
    let memberavatar = member.user.avatarURL
    const fromNow = moment(member.joinedTimestamp).fromNow();
   
    let embed = new Discord.RichEmbed()
       .setAuthor(`${member.user.tag}`, member.user.avatarURL)
       .setColor('#36393e')
       .setDescription(` <@${member.user.id}> Left From The Server`)
       .setTimestamp();
     channel.send({embed:embed});
});
 
client.on('messageDelete', message => {
    if (!message || !message.id || !message.content || !message.guild || message.author.bot) return;
    const channel = message.guild.channels.find('name', 'log');
    if (!channel) return;
   
    let embed = new Discord.RichEmbed()
       .setAuthor(`${message.author.tag}`, message.author.avatarURL)
             .setTitle('Message Deleted')
       .addField('Deleted Message',`${message.cleanContent}`)
       .addField('Deleted In',`<#${message.channel.id}>`)
       .addField('By', `<@${message.author.id}> `)
       .setColor('#36393e')
       .setTimestamp();
     channel.send({embed:embed});
 
});

     
      client.on("roleDelete", role => {
  client.setTimeout(() => {
    role.guild.fetchAuditLogs({
        limit: 1,
        type: 30
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username)
        try {

          let log = role.guild.channels.find('name', 'log');
          if (!log) return;
          let embed = new Discord.RichEmbed()
            .setColor('#36393e')          
            .setTitle(' - Role Deleted ')
            .addField('Role Name', role.name, true)
            .addField('Role ID', role.id, true)
            .addField('Role Color', role.hexColor, true)
            .addField('Role Permission', role.permissions, true)
            .addField('By', exec, true)
            .setColor('#36393e') 
            .setTimestamp()
          log.send(embed).catch(e => {
            console.log(e);
          });
        } catch (e) {
          console.log(e);
        }
      })
  }, 1000)
})


client.on('roleCreate', role => {
  client.setTimeout(() => {
    role.guild.fetchAuditLogs({
        limit: 1,
        type: 30
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username)
        try {

          let log = role.guild.channels.find('name', 'log');
          if (!log) return;
          let embed = new Discord.RichEmbed()
            .setTitle('+ Role Created')
            .addField('Role Name', role.name, true)
            .addField('Role ID', role.id, true)
            .addField('Role Color', role.hexColor, true)
            .addField('Role Permission', role.permissions, true)
            .addField('By', exec, true)
            .setColor('#36393e') 
            .setTimestamp()
          log.send(embed).catch(e => {
            console.log(e);
          });
        } catch (e) {
          console.log(e);
        }
      })
  }, 1000)
})




  client.on("guildBanAdd", (guild, member) => {
  client.setTimeout(() => {
    guild.fetchAuditLogs({
        limit: 1,
        type: 22
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username);
        try {
          let log = guild.channels.find('name', 'log');
          if (!log) return;
          client.fetchUser(member.id).then(myUser => {
          let embed = new Discord.RichEmbed()
        .setAuthor("Banned")
	    .setColor('#36393e') 
        .setThumbnail(myUser.avatarURL)
        .addField('Banned User :',`**${myUser.username}**`,true)
        .addField('Banned By :',`**${exec}**`,true)
        .setFooter(myUser.username,myUser.avatarURL)
            .setTimestamp();
          log.send(embed).catch(e => {
            console.log(e);
          });
          });
        } catch (e) {
          console.log(e);
        }
      });
  }, 1000);
});



    client.on("guildBanRemove", (guild, member) => {
  client.setTimeout(() => {
    guild.fetchAuditLogs({
        limit: 1,
        type: 22
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username);
        try {
          let log = guild.channels.find('name', 'log');
          if (!log) return;
          client.fetchUser(member.id).then(myUser => {
          let embed = new Discord.RichEmbed()
        .setAuthor("UnBanned")
		.setColor('#36393e') 
		 .setThumbnail(myUser.avatarURL)
        .addField('UnBanned User',`**${myUser.username}**`,true)
        .addField('UnBanned By',`**${exec}**`,true)
        .setFooter(myUser.username,myUser.avatarURL)
            .setTimestamp();
          log.send(embed).catch(e => {
            console.log(e);
          });
          });
        } catch (e) {
          console.log(e);
        }
      });
  }, 1000);
});










client.on('message',message =>{
    var prefix = "$";
    if(message.content.startsWith(prefix + 'top')) {
  message.guild.fetchInvites().then(i =>{
  var invites = [];
   
  i.forEach(inv =>{
    var [invs,i]=[{},null];
     
    if(inv.maxUses){
        invs[inv.code] =+ inv.uses+"/"+inv.maxUses;
    }else{
        invs[inv.code] =+ inv.uses;
    }
        invites.push(`invite: ${inv.url} inviter: ${inv.inviter} \`${invs[inv.code]}\`;`);
   
  });
  var embed = new Discord.RichEmbed()
  .setColor("#000000")
  .setDescription(`${invites.join(`\n`)+'\n\n**By:** '+message.author}`)
  .setThumbnail("https://media.discordapp.net/attachments/477570106755383307/479229377037598720/22713057_151850495552450_709700562_o.jpg?width=201&height=201")
           message.channel.send({ embed: embed });
   
  });
   
    }
  });







client.login(process.env.BOT_TOKEN);
